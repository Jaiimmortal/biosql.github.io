This document describes some of the tables and fields in the PhyloDB schema. It also aims to demonstrate functional capabilities using example SQL. Design philosophies and expectations are presented with reasoning. 

=Tree Tables=

==TREE==
Tree stores information on individual bifurcating non-cyclic graphs. Trees are uniquely identified by thier "tree_id". They also have a "name" and "identifier". They are associated with a BioSQL biodatabase via their "biodatabase_id". The Boolean field "is_rooted" identifies whether a node is rooted or not. The default is TRUE, i.e. rooted. "Node_id" identfies the ''start'' node which is usually the root node of a rooted tree.

===Questions about TREE?===
#Where do "identifier"s come from?
#What is the role of the ''start'' node except to identify the root?

==TREE_ROOT==
Tree_root stores information on the root node of a tree. Tree roots are uniquely identified by thier "tree_root_id". The tree the root is from is identified by the "tree_id" while the node table record is identified by "node_id". "is_alternate" is TRUE if the root node is the preferential (most likely) root node of the tree, and FALSE otherwise. The "significance" (such as likelihood, or posterior probability) with which the node is the root node. This only has meaning if the method used for reconstructing the tree calculates this value.

==TREE_QUALIFIER_VALUE==
This stores metadata associated with an entire tree. "tree_id" identifies the tree with which the metadata is associated. The name of the metadata element as a BioSQL term from a controlled vocabulary (or ontology) is identified by the foreign key "term_id". The value of the metadata element is stored as text in "value". The "rank" field stores the index of the metadata value if there is more than one value for the same metadata element. If there is only one value, this may be left at the default of zero.

===Questions about TREE_QUALIFIER_VALUE===
#Why is use rank and not tow tree qualifiers?

==TREE_Dbxref==
Stores information on database cross-references assigned to the tree. "tree_id" identifies the tree to which the database corss-reference is being assigned. "dbxref_id" is the database cross-reference assigned to the tree. "term_id" is the type of the database cross-reference as a controlled vocabulary or ontology term. The type of a tree accession should be 'primary identifier'.

=Node Tables=

==NODE==
The node table stores information on the nodes within trees. Each node is uniquely identified through its "node_id". Nodes may ne "label"ed, e.g. with the latin binomial of the taxon, taxonomic rank, the accession number of a sequences, or any other construct that uniquely identifies the node within one tree. "tree_id" specifies which tree each node is a part of. "left_idx and "right_idx" specify the left and right values of the nested set optimization structure for efficient hierarchical queries. These values needs to be precomputed by a program, see J. Celko, SQL for Smarties.

===Questions about NODE===
#How do I compute "left_idx" and "right_idx"?

==NODE_PATH==

==NODE_TAXON==

==NODE_BIOENTRY==

==NODE_Dbxref==

=Edge Tables=

==EDGE_QUALIFIER_VALUE==

==EDGE==

==EDGE_QUALIFIER_VALUE==